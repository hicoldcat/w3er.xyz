---
title: Web3系列教程之进阶篇---2. Layer 1 替代链
description: null
author: 李留白
weight: 0
date: 2022-07-19T14:37:49.364Z
lastmod: 2022-07-19T14:38:11.770Z
tags: []
categories:
  - 区块链
  - WEB3.0
featuredImage: https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/Dcx1zWU(1).png
---

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220719213633.png)


## 介绍

到目前为止，我们已经看了以太坊，对第二层解决方案做了一些阅读，并将Polygon网络用于大部分入门课程。然而，也存在多个其他第1层区块链值得关注。在这篇文章中，我们将谈一谈几个不同的第一层区块链。


## Layer 1 vs Layer 2

第1层和第2层是用来描述区块链 "类型 "的术语。第1层区块链是那些主要的区块链本身，而第2层区块链是那些在第1层区块链之上的覆盖网络。

例如，以太坊和比特币是第一层区块链，而Polygon、Arbitrum、Optimism、Lightning Network等是第二层区块链的例子。

第1层区块链直接改变协议的规则，试图扩大规模或提供更好的可用性。例如，它们可以包括增加每个块中包含的数据量，或者加快每个块的块确认时间，以提高总吞吐量。通常，这是以降低安全性和/或去中心化为代价的，因为增加了运行节点的硬件要求，或增加了成为抽样证明系统中验证者的成本，等等。

第一层区块链的例子包括以太坊、NEAR、Flow、Avalanche、Solana、Algorand、比特币等。

第二层区块链指的是在底层第一层区块链之上运行的网络，试图提高可扩展性和效率，同时从主链获得安全和去中心化的好处。这需要将第1层区块链的一些工作转移到第2层网络，并且只使用第1层交易进行结算--例如，在第2层网络上执行1000个交易，将其结果汇编在一起，并在单一交易中在第1层区块链上发布有效性证明。

第二层区块链的例子包括Polygon*、Optimism、Arbitrum、zkSync、Lightning Network等。

> *Polygon的PoS链是第二层的一个松散的例子，因为它是Plasma的实现，本质上是一个侧链，它也向主链发布汇总的数据快照。它定期在以太网络上以压缩形式编译和锚定Polygon的链的状态。但是，由于它没有提供已经执行的交易的有效性证明，所以信任仍然放在Polygon网络的验证器组中。因此，它并没有完全获得以太坊的安全优势，但是会定期向以太网发布状态更新，所以如果 Polygon 被破坏，它可以在以太网的最新检查点恢复*.

现在，我们将看看几个不同的第一层区块链，并尝试将它们与以太坊进行比较。

## NEAR Protocol

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220719214820.png)

NEAR是一个第一层智能合约平台，利用平行存储和计算技术进行扩展。它还使用股权证明共识，而不是以太坊目前的工作证明，并且有50多个验证者在网络上保证数百万美元的安全。

#### 什么是分片?

分片这个词意味着一个整体的一小部分。在区块链的背景下，分片只是意味着网络上的每一个节点都需要处理每一笔交易（就像以太坊写的那样），而区块链被分割成多个小部分，每个验证者只需要担心它所在的分片上正在执行的交易。

这允许在不同的分片上对交易进行并行计算。这使得交易的处理速度更快，因此可扩展性更高。

#### 如何管理分片？

管理所有单个分片的常见方法是有一个Beacon链，作为所有分片的 "管理者"。它负责将验证者随机分配给特定的分片，单独接收每个分片的更新，并对其进行全局快照，以及在股权证明共识中处理赌注和砍价。

现在可扩展性的瓶颈变成了Beacon链，因为它负责整个全球的状态。然而，如果网络中的每个节点都变得快4倍，包括Beacon链上的节点，每个分片就能多处理4倍的交易，同时Beacon链也能管理4倍的分片。因此，总体而言，这将导致总交易处理量增加16倍。这就是所谓的二次分片。

#### 如果有分叉呢？

虽然分片链+Beacon 链的模式很强大，但当我们谈论到如果链分叉会发生什么时，它就有了复杂性。哪个链成为 "真正的 "链的决定需要在每个分片上单独做出，而且Beacon 链和分片链的逻辑是不同的。

由于这个原因，NEAR遵循了一个稍有改进的模型。在NEAR中，系统在逻辑上被建模为一个单一的区块链，每个区块包含所有区块的所有交易，并同时改变所有分块的状态。因此，如果发生分叉，整个链条有效地最终选择一个单一的、逻辑上最长的链条。然而，在物理上，没有一个参与者需要下载区块的全部状态，而只下载与他们的分片相关的状态。

#### 与多个分片互动的交易是如何运作的？

如果单个分片不能相互通信，那么分片就相当无用，它们并不比多个独立的区块链相互通信更好。

考虑下面的例子:

1. Alice 有个账户在1号碎片上
2. Bob 有个账户就存在2号碎片上
3. Alice 想给Bob 转账
4. 1号碎片上的验证程序无法将钱转给Bob
5. 碎片2上的验证器不能从 Alice 那里扣钱

这要怎么做？

在NEAR中，如果一个事务影响到1个以上的分片，它将在每个分片中分别连续执行。整个交易首先被发送到第一个被影响的分片。一旦交易被执行，就会产生一个收据交易，它被传递给下一个受影响的分片。如果有更多的分片受到影响，就会产生更多的收据交易，并进一步向下传递。

每个后续的分片可以验证收据交易，并得到确认，前面的分片已经完成了他们的工作。然后，它执行该分片上需要发生的任何事情，如果有更多的分片受到影响，则结束该事务或进一步传递。

#### 在NEAR上开发

NEAR第一层区块链的智能合约可以用Rust或AssemblyScript编写。与区块链节点的通信可以通过HTTP API（类似于Ethereum）完成。

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220719215805.png)

值得注意的是，NEAR还运行一个名为Aurora的以太坊第二层区块链，它也使用原生ETH代币作为第二层的原生气体代币。

#### 与 Ethereum 相比

- 对于开发者来说，主要的区别是用于开发的语言。虽然你可以将Solidity用于Aurora第二层网络，但NEAR协议不仅仅是Aurora，不支持Solidity在原生NEAR区块链上部署。
- 对于第1层区块链，原生代币是$NEAR，而不是$ETH
- NEAR上的账户有人类可读的名字，而不是像以太坊上的随机字母和数字。
- NEAR允许开发者升级他们的智能合约。然而，他们也提供了一种方法，可以为特定的合同永久地删除这个选项，以增强智能合同的安全性和真正的无信任操作。
- 开发者们不使用Etherscan，而是使用**NEAR Explorer**查看块和事务
- 开发人员可以使用nearup命令行工具来运行本地测试节点，而不是通过Hardhat或Ganache运行本地测试节点。
- NEAR的验证者/参与者明显少于Ethereum。这是由于成为验证者的要求很高。截至发稿时，购买足够的NEAR美元并将其入股以成为其网络上的验证者需要花费超过100万美元。

## Flow 链

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220719220303.png)

Flow将自己描述为一个 "快速、去中心化、对开发者友好的区块链"。他们基于一个多角色架构，并被设计为无需分片就能扩展。

Flow 是建立在四个基础之上的，这四个基础使其独特，值得讨论。

- 多角色架构
- 面向资源的编程
- 可升级的智能合约
- 从法币到加密货币的便捷通道

让我们单独看一下这些，并理解它们。

#### 多角色架构

在传统的区块链中，每个节点负责存储区块链的整个状态并执行所有相关工作。这类似于让一个工人建造整个汽车。

然而，在现实世界中，没有一个工人能造出一辆完整的汽车。一个常见的过程是流水线——任务按顺序交给从事不同工作的不同人员。

Flow 通过将验证器节点的作业分成四个不同的角色，将流水线的概念应用到区块链中:

1. 收集
2. 达成共识
3. 执行
4. 验证

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220719220624.png)

观察上图，我们可以看到，较早的区块在流水线阶段的位置较远。例如，B1处于执行状态，而B2正在验证B1，然后再转到执行B2。B3此时正在对它的事务进行一致性处理，并将最终验证 B2，然后执行 B3，以此类推。

与采取横向扩展方式的分片不同，Flow是纵向扩展的。这意味着，即使每个验证器节点参与验证每个交易，它们也只在验证阶段这样做。因此，它们可以在特定的阶段专注于特定的任务。这使得 Flow 可以比当前的传统区块链扩展数千倍。

#### 面向资源的编程

Flow上的智能合约是用一种叫做Cadence的编程语言开发的。Cadence被定义为 "第一个符合人体工程学、面向资源的智能合约编程语言"。

面向资源的编程是一种新的语言设计范式，被设计为安全和易于使用。Cadence是第一个面向资源的高级编程语言。它是静态类型的，就像Solidity，并为数据存储和数据所有权提供了非常有力的保证。

像数字资产一样，“资源”的所有权是由编程语言直接支持的，而不必手动管理数据的生命周期。

将某样东西标记为资源并告诉编程语言，这个数据代表了某种有价值的东西，所有与该数据交互的代码都需要遵循特殊的规则来维护数据的价值。

1. 每个资源在任何时候都只能存在于一个地方。资源不能被复制或意外删除，通过编程错误或通过恶意代码。
2.  资源的所有权由其存储在代码中的位置定义
3. 对一个资源上的方法的访问只限于所有者。例如，只有一个NFT的所有者可以启动一个修改该NFT的函数。通过将NFT的数据放入所有者的存储中，这一点被直接构建在语言中，而不是必须创建

面向资源的编程是一个很大的话题，在这里要完全深入地探讨。要阅读和了解更多关于它的信息，[你可以在这里找到更多相关信息。](https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e)

#### 可升级的智能合约和日志

智能合约平台做出的承诺是，用户不需要信任开发者，而可以信任代码。以太坊的设计使智能合约不能升级，因为如果代码不能升级，那么在作者部署智能合约后，你就不需要再相信他们。

不幸的是，要让软件第一次就不出错是非常困难的。[Rekt News](https://rekt.news/)有一个巨大的智能合约清单，由于原始设计中的微小错误而被黑掉了数百万，其中一些甚至在专业审计后也没有被发现。

在Flow上，开发者可以选择将智能合约以 "测试状态 "部署到主网上。在这种状态下，代码可以由原作者逐步更新。用户在与合约互动时，会被警告该合约处于测试状态，并可以选择等待，直到代码最终完成。一旦作者确信他们的代码是安全的，他们就可以释放合约的控制权，此后它就永远不可升级了。

#### 对消费者友好的入门教程

Flow一直专注于让主流人群易于使用。当与Flow上的dApp进行交互时，Flow交易格式对交易可以和不可以进行何种改变做出了强有力的保证，因此钱包可以向用户提供人类可读的信息，以帮助他们对批准的内容做出明智的决定。

#### 与 Ethereum 相比

- Flow 使用股权证明的共识
- Flow是一个较新的生态系统，它的社区和受众较少，但他们有很好的文档和开发者工具可以开始使用。
- Flow被明确设计为支持需要高扩展性的游戏和消费者应用程序的运行。这并不奇怪，因为Flow是由Dapper Labs构建的--该团队因开发CryptoKitties（首批NFT项目之一）而闻名，该项目堵塞了以太坊区块链，也因开发NBA TopShot--最受欢迎的NFT项目，并与NBA正式合作。NBA TopShot是建立在Flow之上的。
- Flow 上的执行节点具有非常高的风险和硬件要求。与 Etherum 不同，Flow 执行节点可能是数据中心中的高端服务器硬件集群
- 目前Flow上的大多数应用都是由其背后的团队直接制作的。尽管目前正在开发更多的应用程序，而且该团队正在积极尝试在生态系统中加入更多的外部开发者。

## Avalanche

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220719221855.png)

Avalanche是一个开源平台，用于在一个可互操作的区块链生态系统中构建dApps和企业平台。它是一个智能合约平台，提供高吞吐量和近乎即时的交易终结性。另外，Avalanche支持Solidity，所以以太坊的智能合约可以很容易地移植到Avalanche。

Avalanche是一个生态系统，而不是一个单一的区块链。在Avalanche生态系统的基础上，可以存在多种链。最受欢迎的是Avalanche C-Chain，它是一个EVM兼容链，支持Solidity智能合约。然而，全新的区块链系统可以在Avalanche生态系统中建立，具有不同的属性。

#### Avalanche设计架构

**子网络**： 一个子网络（或子网），是一组验证程序，它们在一组区块链上达成一致。Avalanche上的每个区块链都由一个子网验证，但每个子网可以验证多个区块链。一个特定的验证者可以是多个子网的一部分。如果一个验证者不关心一个特定的子网，他们不需要加入这个子网。此外，由于子网可以控制谁进入它们，可以创建私人子网，这类似于私人或许可的区块链。

**虚拟机**： Avalanche上的每个区块链必须是一个虚拟机。当一个新的链被创建时，它必须指定它要使用的虚拟机--要么是已经存在的东西，要么是开发者的新实现。这就是C-Chain能够支持Ethereum虚拟机和支持Solidity的原因，而Avalanche上的其他链却没有。

**AVAX代币**： Avalanche上的所有区块链都使用本地代币$AVAX来支付网络上的操作。AVAX也可以作为以太坊上的ERC-20，可以桥接到Avalanche的C链上。

AVAX代币有一个固定的硬性上限，所以存在的AVAX代币永远不可能超过720,000,000。AVAX的货币政策可以随着时间的推移而改变，以应对不断变化的经济状况。

#### 在Avalanche上开发

除了创建自己的子网，Avalanche用于的主要链是C-Chain。部署到C-Chain与部署到Ethereum第二层非常相似。你只需要获得一个Avalanche节点的RPC URL，就可以使用你已经熟悉的工具--Hardhat、Truffle、Remix等，将你的Solidity智能合约部署到C链上。你也可以使用Metamask作为Avalanche C-Chain的钱包。

#### 与 Ethereum 相比

- Avalanche具有更快的交易终结性，而且使用成本更低
- 在C-Chain和以太坊上的开发几乎完全相同
- AVAX代币是有硬性上限的，不像ETH那样没有硬性上限
- Avalanche使用自定义的 "权益证明 "共识协议，而不是以太坊的 "工作证明"。
- Avalanche C-Chain的交易内存池是不公开的，只限于验证者。这可能是个问题，因为区块生产者有很大的优势，他们可以通过了解接下来的交易内容来获利，例如在DEX交易中做套利。
- 在撰写本报告时，要成为Avalanche生态系统的验证者，需要花费15万美元以上的资金。

## Solana

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220719222646.png)

最近，Solana被谈论了很多，并在新闻中不断出现。他们有一些好日子，也有一些坏日子，但在本节中，我们将尝试介绍一下他们在引擎盖下运行的技术。

Solana是一个带有一些额外技术的权益证明区块链。这个附加技术中最重要的部分是他们称之为历史证明的东西。

#### 历史证明

基本上， Solana的假设是，设计区块链的最大技术挑战之一是缺乏一个共享的时钟。由于缺乏一个共享的时钟，很难让一个由节点组成的分布式系统就事物的顺序达成一致。像以太坊和比特币这样的区块链使用区块编号（或区块高度）来为交易提供排序，但这有一个缺点，即交易在区块时间过去之前不会完成执行（比特币约10分钟，以太坊约15秒）。

Solana采用了一种截然不同的历史证明方法。它不再有区块和区块时间，而是要求验证者签署加密证明，这些证明可以证明自他们提供的最后一个证明以来已经过去了一些时间。这是通过对以前的散列输出进行散列来实现的。所有被散列到证明中的数据必须在证明创建之前就已经存在。然后验证者与所有其他节点分享，这些节点可以复制新的散列值，并足够快地验证加密证明。

其他大多数优化就是这样，对区块链的较小方面进行优化，使其工作得更快。

#### 领导者选择

Solana有确定的领导者选择。这意味着，当一个交易被创建时，网络已经知道谁将是下一个区块的创建者，并可以直接将交易数据转发给该领导者。与比特币和以太坊不同，在与其他矿工的竞争中没有 "竞赛 "或 "拼图 "需要解决。这也有它的缺点，因为确定性的领导者选择意味着，由于领导者是提前知道的，他们可能会受到DDoS攻击。

#### 妥协

Solana 真的很快。但为了达到这个速度，它在哪些方面做出了妥协？除了确定性的领导者选择的缺点外，其余的权衡都落在了dApp开发者身上。

Solana为实现快速交易所需的大部分复杂性都交给了dApp开发者来处理。如果你曾经看过Solana关于如何用Rust写程序的文档，它看起来比看Solidity要吓人得多。这个系统要复杂得多，也更难处理，很多事情都需要由终端开发者来完成。

这种权衡或许没什么问题。该链真的很快，但也真的很难建立复杂的应用程序。随着时间的推移，社区可能会创建抽象，并隐藏大部分的复杂性，但如果你想了解基本原理，以便在出现奇怪的问题时能够解决，那么你需要知道，这并不容易。复杂性也可能是Solana没有看到那么多骗局的原因，不是因为Solana上的代码没有漏洞，而是因为世界上很少有开发者能够编写Solana程序，更不用说反向工程和发现其中的漏洞了。

#### 无状态区块链

Solana和Ethereum的另一个最大区别是，Solana智能合约是无状态的，而Ethereum智能合约是有状态的。到此为止，你已经习惯了在Solidity代码中存储变量、数组、映射等。Solana不允许这样做。Solana中的合约不能自己存储任何东西。

在Solana上，代码和数据之间是分离的，对系统的整体设计有广泛的影响。Solana上的任何数据都存储在称为账户的东西中。这个术语是来自以太坊的最大混乱来源，因为Solana上的账户并不指钱包或地址等。说实话，这里的术语有点奇怪。

账户是数据存储，可以为预先定义的固定规模的数据创建账户。为了存储数据，需要为账户支付租金。账户可以存储$SOL代币，这些代币会随着时间的推移被扣除，作为它在网络上使用的存储空间的租金。

#### Solana的交易记录

在Solana上，操作的基本单位被称为指令。一条指令是对一个程序（或智能合约）的单一调用。一条或多条指令可以连续地捆绑在一起，成为一条消息。一条消息由发送者签署，形成一个交易。

这是与以太坊的另一个区别。在以太坊中，交易是指对智能合约的签名调用，而智能合约可以做任何它想做的事情（包括调用其他智能合约）。这在Solana上是不可能的。同样，复杂性也被移交给了开发者和用户。用户需要构建交易，而交易是进入多个程序的一组指令，要么全部成功，要么全部失败。因此，构建dApp的开发者需要在前端侧编写这些代码，而不是只在程序中设置一个入口点，在程序中完成所有的事情。

当在一个事务中传递多个指令时，顺序很重要，因为那是它们将被执行的顺序。dApp开发者需要特别注意，确保他们不会弄乱顺序。前端存在创建不正确事务的风险。

总的来说，Solana有它自己的一套优点和缺点。它非常快，而且肯定取得了一些良好的技术进步。缺点是影响了开发者的体验，在Solana上开发dApps比在Ethereum（或任何EVM兼容链）上要难得多。

## 结论

我希望通过这篇文章，你能够对不同的第一层以及他们所采取的不同方法有一些了解。这份文件也应该作为证明，我们在市场上还处于相当早期的阶段，很可能不是所有的这些链子都会随着时间的推移，随着明显的赢家出现而继续得到普及和广泛使用。


> 原文： [https://www.learnweb3.io/tracks/junior/alternative-layer-1s](https://www.learnweb3.io/tracks/junior/alternative-layer-1s)

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/my.png)
