---
title: Web3ç³»åˆ—æ•™ç¨‹ä¹‹é«˜çº§ç¯‡---12ï¼šä½¿ç”¨å…ƒäº¤æ˜“æ”¯ä»˜å…¶ä»–äººçš„äº¤æ˜“ç‡ƒæ–™è´¹
description: null
author: æç•™ç™½
weight: 0
date: 2022-08-11T13:37:41.543Z
lastmod: 2022-08-11T14:53:37.175Z
tags: []
categories:
  - åŒºå—é“¾
  - WEB3.0
featuredImage: https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/R3RYera.png
---

æœ‰äº›æ—¶å€™ï¼Œä½ å¸Œæœ›ä½ çš„DAppç”¨æˆ·æœ‰ä¸€ä¸ªæ— ç‡ƒæ–™è´¹çš„ä½“éªŒï¼Œæˆ–è€…ä¹Ÿè®¸åœ¨æ²¡æœ‰çœŸæ­£æŠŠä¸œè¥¿æ”¾åœ¨é“¾ä¸Šçš„æƒ…å†µä¸‹è¿›è¡Œäº¤æ˜“ã€‚è¿™äº›ç±»å‹çš„äº¤æ˜“è¢«ç§°ä¸ºå…ƒäº¤æ˜“ï¼Œåœ¨è¿™ä¸ªå±‚é¢ä¸Šï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨å¦‚ä½•è®¾è®¡å…ƒäº¤æ˜“ï¼Œä»¥åŠå¦‚æœä¸ä»”ç»†è®¾è®¡ï¼Œå®ƒä»¬å¦‚ä½•è¢«åˆ©ç”¨ã€‚

å¯¹äºé‚£äº›ä½¿ç”¨è¿‡OpenSeaçš„äººï¼Œæœ‰æ²¡æœ‰æ³¨æ„åˆ°OpenSeaæ˜¯å¦‚ä½•è®©ä½ å…è´¹åˆ¶ä½œNFTçš„ï¼Ÿæ— è®ºæ‚¨æƒ³ä»¥ä»€ä¹ˆä»·æ ¼å‡ºå”®NFTï¼Œå®ƒéƒ½ä¸ä¼šåœ¨åˆå§‹NFTæ‰¹å‡†äº¤æ˜“ä¹‹å¤–æ”¶å–å¤©ç„¶æ°”è´¹ç”¨ï¼Ÿç­”æ¡ˆæ˜¯å…ƒäº¤æ˜“ã€‚

å…ƒäº¤æ˜“ä¹Ÿå¸¸ç”¨äºæ— ç‡ƒæ–™è´¹çš„äº¤æ˜“ä½“éªŒï¼Œä¾‹å¦‚è¦æ±‚ç”¨æˆ·ç­¾ç½²ä¸€ä¸ªä¿¡æ¯æ¥ç´¢å–NFTï¼Œè€Œä¸æ˜¯æ”¯ä»˜æ°”ä½“æ¥å‘é€äº¤æ˜“æ¥ç´¢å–NFTã€‚

ä¹Ÿæœ‰å…¶ä»–çš„ç”¨ä¾‹ï¼Œä¾‹å¦‚è®©ç”¨æˆ·ç”¨ä»»ä½•ä»£å¸ï¼Œç”šè‡³æ˜¯æ³•å¸æ¥æ”¯ä»˜æ±½æ²¹è´¹ï¼Œè€Œä¸éœ€è¦è½¬æ¢ä¸ºåŠ å¯†è´§å¸ã€‚Multisigé’±åŒ…ä¹Ÿåªè¦æ±‚æœ€åä¸€ä¸ªç­¾åè€…ä¸ºæ­£åœ¨ä»multisigé’±åŒ…è¿›è¡Œçš„äº¤æ˜“æ”¯ä»˜æ±½æ²¹è´¹ï¼Œå…¶ä»–ç”¨æˆ·åªæ˜¯ç­¾ç½²ä¸€äº›ä¿¡æ¯ã€‚

è¿™æ˜¯ä¸æ˜¯çœŸçš„å¾ˆé…·ï¼ŸğŸ‰

## å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ

å…ƒäº¤æ˜“åªæ˜¯ä¸€ä¸ªèŠ±å“¨çš„è¯ï¼Œå³ç”±ç¬¬ä¸‰æ–¹ï¼ˆä¸­ç»§è€…ï¼‰ä»£è¡¨ç”¨æˆ·æ”¯ä»˜äº¤æ˜“çš„æ°”ä½“ã€‚ç”¨æˆ·åªéœ€è¦ç­¾ç½²åŒ…å«ä»–ä»¬æƒ³è¦æ‰§è¡Œçš„äº¤æ˜“ä¿¡æ¯çš„æ¶ˆæ¯ï¼ˆè€Œä¸æ˜¯å‘é€äº¤æ˜“ï¼‰ï¼Œå¹¶æŠŠå®ƒäº¤ç»™ä¸­ç»§è€…ã€‚ç„¶åï¼Œä¸­ç»§è€…è´Ÿè´£ä½¿ç”¨è¿™äº›æ•°æ®åˆ›å»ºæœ‰æ•ˆçš„äº¤æ˜“ï¼Œå¹¶è‡ªå·±æ”¯ä»˜ç‡ƒæ°”è´¹ã€‚

ä¸­ç»§è€…å¯ä»¥æ˜¯ï¼Œä¾‹å¦‚ï¼Œä½ çš„DAppä¸­çš„ä»£ç ï¼Œè®©ä½ çš„ç”¨æˆ·ä½“éªŒæ— æ°”äº¤æ˜“ï¼Œä¹Ÿå¯ä»¥æ˜¯ä½ ç”¨æ³•å¸æ”¯ä»˜çš„ç¬¬ä¸‰æ–¹å…¬å¸ï¼Œåœ¨ä»¥å¤ªåŠä¸Šæ‰§è¡Œäº¤æ˜“ï¼Œç­‰ç­‰ã€‚

åœ¨è¿™ä¸€å±‚æ¬¡ï¼Œæˆ‘ä»¬å°†åšä¸¤ä»¶äº‹--å­¦ä¹ å…ƒäº¤æ˜“ä»¥åŠå¦‚ä½•æ„å»ºä¸€ä¸ªæ”¯æŒå…ƒäº¤æ˜“çš„ç®€å•æ™ºèƒ½åˆçº¦ï¼ŒåŒæ—¶å­¦ä¹ æˆ‘ä»¬æ„å»ºçš„ç¬¬ä¸€ä¸ªåˆçº¦ä¸­çš„ä¸€ä¸ªå®‰å…¨æ¼æ´ä»¥åŠå¦‚ä½•ä¿®å¤å®ƒã€‚ä¸€çŸ³äºŒé¸ŸğŸ˜ã€‚

## æ•°å­—ç­¾å

åœ¨å‰é¢çš„IPFSçº§åˆ«ä¸­ï¼Œæˆ‘ä»¬å·²ç»è§£é‡Šäº†ä»€ä¹ˆæ˜¯æ•£åˆ—ã€‚åœ¨ç»§ç»­ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£å¯†ç å­¦çš„ç¬¬äºŒä¸ªåŸºæœ¬æ¦‚å¿µ--æ•°å­—ç­¾åã€‚

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/20220811221450.png)

æ•°å­—ç­¾åæ˜¯ä¸€ç§éªŒè¯ä¿¡æ¯çœŸå®æ€§çš„æ•°å­¦æ–¹æ³•ã€‚ç»™å®šä¸€äº›æ•°æ®ï¼Œä¸€ä¸ªç§é’¥å¯ä»¥ç”¨æ¥ç­¾ç½²è¯¥æ•°æ®å¹¶äº§ç”Ÿä¸€ä¸ªæœ‰ç­¾åçš„ä¿¡æ¯ã€‚

ç„¶åï¼Œå…¶ä»–è®¤ä¸ºè‡ªå·±æ‹¥æœ‰åŸå§‹è¾“å…¥æ•°æ®çš„äººå¯ä»¥å°†å…¶ä¸ç­¾åçš„ä¿¡æ¯è¿›è¡Œæ¯”è¾ƒï¼Œä»¥æ£€ç´¢å‡ºç­¾åä¿¡æ¯çš„å…¬é’¥ã€‚ç”±äºå‘é€è€…çš„å…¬é’¥å¿…é¡»äº‹å…ˆçŸ¥é“ï¼Œä»–ä»¬å¯ä»¥ä¿è¯æ•°æ®æ²¡æœ‰è¢«ç¯¡æ”¹ï¼Œå…¶å®Œæ•´æ€§å¾—åˆ°ç»´æŠ¤ã€‚

æ‰€ä»¥åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼ŒAliceç”¨å¥¹çš„ç§é’¥ç­¾ç½²äº†`Hello Bobï¼`è¿™ä¸ªæ¶ˆæ¯å¹¶æŠŠå®ƒå‘é€ç»™Bobã€‚Bobå·²ç»çŸ¥é“å†…å®¹æ˜¯`Hello Bobï¼`ç°åœ¨ä»–æƒ³éªŒè¯è¯¥ä¿¡æ¯ç¡®å®æ˜¯ç”±Aliceå‘é€çš„ï¼Œæ‰€ä»¥ä»–è¯•å›¾ä»ç­¾ç½²çš„ä¿¡æ¯ä¸­æ£€ç´¢å‡ºå…¬é’¥ã€‚å¦‚æœå…¬é’¥æ˜¯Aliceçš„å…¬é’¥ï¼Œé‚£ä¹ˆè¯¥ä¿¡æ¯å°±æ²¡æœ‰è¢«ç¯¡æ”¹ï¼Œæ˜¯å®‰å…¨ä¼ è¾“çš„ã€‚

### æ•°å­—ç­¾åçš„ä½¿ç”¨æ¡ˆä¾‹

æ•°å­—ç­¾åé€šå¸¸ç”¨äºæƒ³è¦å®‰å…¨é€šä¿¡å’Œç¡®ä¿ä¿¡æ¯å†…å®¹åœ¨é€šä¿¡è¿‡ç¨‹ä¸­æ²¡æœ‰è¢«æ“çºµçš„æƒ…å†µã€‚ä½ å¯ä»¥å‘é€åŸå§‹æ˜æ–‡ä¿¡æ¯ï¼Œä»¥åŠæ¥è‡ªå·²çŸ¥å‘é€è€…çš„ç­¾åä¿¡æ¯ï¼Œæ¥æ”¶è€…å¯ä»¥é€šè¿‡æ¯”è¾ƒæ˜æ–‡ä¿¡æ¯å’Œç­¾åä¿¡æ¯å¾—å‡ºç­¾åè€…çš„å…¬é’¥æ¥éªŒè¯ä¿¡æ¯çš„å®Œæ•´æ€§ã€‚å¦‚æœç­¾åè€…çš„å…¬é’¥ä¸é¢„æœŸçš„å‘é€è€…çš„å…¬é’¥ç›¸åŒ¹é…ï¼Œé‚£ä¹ˆè¯¥ä¿¡æ¯å°±è¢«å®‰å…¨åœ°ä¼ é€äº†ã€‚

### ä»¥å¤ªåŠä¸Šçš„æ•°å­—ç­¾å

åœ¨ä»¥å¤ªåŠçš„æƒ…å†µä¸‹ï¼Œç”¨æˆ·é’±åŒ…å¯ä»¥ç­¾ç½²æ¶ˆæ¯ï¼Œç„¶ååŸå§‹è¾“å…¥æ•°æ®å¯ä»¥ä¸ç­¾ç½²çš„æ¶ˆæ¯è¿›è¡ŒéªŒè¯ï¼Œä»¥æ£€ç´¢ç­¾ç½²æ¶ˆæ¯çš„ç”¨æˆ·çš„åœ°å€ã€‚ç­¾åéªŒè¯æ—¢å¯ä»¥åœ¨é“¾å¤–è¿›è¡Œï¼Œä¹Ÿå¯ä»¥åœ¨Solidityå†…éƒ¨è¿›è¡Œã€‚è¿™é‡Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç”¨æˆ·çš„åœ°å€å°±æ˜¯å…¬é’¥ã€‚

## äº†è§£æ¦‚å¿µ

å‡è®¾æˆ‘ä»¬æƒ³å»ºç«‹ä¸€ä¸ªDAppï¼Œç”¨æˆ·å¯ä»¥å°†ä»£å¸è½¬ç§»åˆ°å…¶ä»–åœ°å€ï¼Œè€Œä¸éœ€è¦æ”¯ä»˜æ±½æ²¹ï¼Œåªæœ‰ä¸€æ¬¡æ‰¹å‡†çš„æœºä¼šã€‚ç”±äºç”¨æˆ·è‡ªå·±ä¸ä¼šå‘é€äº¤æ˜“ï¼Œæˆ‘ä»¬å°†ä¸ºä»–ä»¬æ”¯ä»˜æ±½æ²¹ğŸ¤‘.ã€‚

è¿™ç§è®¾è®¡ä¸OpenSeaçš„å·¥ä½œæ–¹å¼éå¸¸ç›¸ä¼¼ï¼Œä¸€æ—¦ä½ æ”¯ä»˜æ°”ä½“æä¾›å¯¹ERC-721æˆ–ERC-1155é›†åˆçš„æ‰¹å‡†ï¼ŒOpenSeaä¸Šçš„åˆ—è¡¨å’Œé”€å”®å¯¹å–å®¶æ¥è¯´æ˜¯å…è´¹çš„ã€‚OpenSeaåªè¦æ±‚å–å®¶åœ¨æŒ‚ç‰Œæ—¶ç­¾ç½²äº¤æ˜“ï¼Œè€Œå½“ä¹°å®¶å‡ºç°æ—¶ï¼Œå–å®¶çš„ç­¾åä¼šä¸ä¹°å®¶çš„äº¤æ˜“ä¸€èµ·æäº¤ï¼Œä»è€Œå°†NFTè½¬ç§»ç»™ä¹°å®¶ï¼Œå¹¶å°†ETHè½¬ç§»ç»™å–å®¶--è€Œä¹°å®¶åˆ™ä¸ºè¿™ä¸€åˆ‡æ”¯ä»˜æ‰€æœ‰çš„æ°”ä½“ã€‚

åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†åªæ˜¯æœ‰ä¸€ä¸ªä¸­ç»§è€…ï¼Œè®©ä½ åœ¨åˆå§‹æ‰¹å‡†åå°†ERC-20ä»£å¸è½¬ç§»åˆ°å…¶ä»–åœ°å€ ğŸ‰ã€‚

è®©æˆ‘ä»¬æƒ³ä¸€æƒ³ï¼Œä¸ºå®ç°è¿™ä¸€ç›®æ ‡éœ€è¦å“ªäº›æ‰€æœ‰çš„ä¿¡æ¯ã€‚æ™ºèƒ½åˆçº¦éœ€è¦çŸ¥é“å…³äºä»£å¸è½¬ç§»çš„æ‰€æœ‰ä¿¡æ¯ï¼Œæ‰€ä»¥æˆ‘ä»¬è‡³å°‘éœ€è¦æŠŠ4ä¸ªä¸œè¥¿çº³å…¥åˆ°ç­¾ç½²çš„æ¶ˆæ¯ä¸­ã€‚
- `sender`åœ°å€
- `recipient`åœ°å€
- `amount`è¦è½¬è®©çš„ä»£å¸æ•°é‡
- `tokenContract`ERC-20æ™ºèƒ½åˆçº¦åœ°å€ã€‚

æµç¨‹å°†çœ‹èµ·æ¥åƒè¿™æ ·:

- ç”¨æˆ·é¦–å…ˆæ‰¹å‡†TokenSenderåˆçº¦ï¼Œä»¥è¿›è¡Œæ— é™çš„ä»£å¸è½¬ç§»ï¼ˆä½¿ç”¨ERC20æ‰¹å‡†åŠŸèƒ½ï¼‰ã€‚
- ç”¨æˆ·ç­¾ç½²åŒ…å«ä¸Šè¿°æ¶ˆæ¯çš„ä¿¡æ¯
- ä¸­ç»§å™¨è°ƒç”¨æ™ºèƒ½åˆçº¦ï¼Œä¼ é€’å·²ç­¾ç½²çš„æ¶ˆæ¯ï¼Œå¹¶æ”¯ä»˜æ±½æ²¹è´¹ã€‚
- æ™ºèƒ½åˆçº¦éªŒè¯ç­¾åå’Œè§£ç ä¿¡æ¯æ•°æ®ï¼Œå¹¶å°†ä»£å¸ä»å‘é€æ–¹è½¬ç§»åˆ°æ¥æ”¶æ–¹

å€¼å¾—åº†å¹¸çš„æ˜¯ï¼Œ`ethers.js`å¸¦æœ‰ä¸€ä¸ªåä¸º`signMessage`çš„å‡½æ•°ï¼Œå¯ä»¥è®©æˆ‘ä»¬è½»æ¾åœ°ç­¾ç½²ä¿¡æ¯ã€‚ç„¶è€Œï¼Œä¸ºäº†é¿å…äº§ç”Ÿä»»æ„é•¿åº¦çš„æ¶ˆæ¯ï¼Œæˆ‘ä»¬å°†é¦–å…ˆå¯¹æ‰€éœ€çš„æ•°æ®è¿›è¡Œæ•£åˆ—ï¼Œç„¶åè¿›è¡Œç­¾åã€‚åœ¨æ™ºèƒ½åˆçº¦ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæˆ‘ä»¬å°†é¦–å…ˆå¯¹ç»™å®šçš„å‚æ•°è¿›è¡Œæ•£åˆ—ï¼Œç„¶åå°è¯•ç”¨æ•£åˆ—æ¥éªŒè¯ç­¾åã€‚

æˆ‘ä»¬å°†ç”¨ä»£ç å†™ä¸€ä¸ªHardhatæµ‹è¯•ï¼Œæ‰€ä»¥é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ç¼–å†™æ™ºèƒ½åˆçº¦ã€‚

## æ„å»º

è®©æˆ‘ä»¬å»ºç«‹ä¸€ä¸ªä¾‹å­ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ä½ å¯ä»¥ä½“éªŒåˆ°å…ƒäº¤æ˜“çš„ä½œç”¨ï¼Œç¨åæˆ‘ä»¬å°†æ‰©å±•è¿™ä¸ªæµ‹è¯•ï¼Œä»¥æ˜¾ç¤ºæ¼æ´ã€‚

- è¦è®¾ç½®ä¸€ä¸ªHardhaté¡¹ç›®ï¼Œè¯·æ‰“å¼€ç»ˆç«¯ï¼Œåœ¨ä¸€ä¸ªæ–°çš„æ–‡ä»¶å¤¹ä¸­æ‰§è¡Œè¿™äº›å‘½ä»¤

```bash
npm init --yes
npm install --save-dev hardhat
```

- å¦‚æœä½ æ˜¯åœ¨Windowsä¸Šï¼Œè¯·åšè¿™ä¸ªé¢å¤–çš„æ­¥éª¤ï¼Œä¹Ÿå®‰è£…è¿™äº›åº“ :)

```
npm install --save-dev @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers
```

- åœ¨ä½ å®‰è£…Hardhatçš„åŒä¸€ç›®å½•ä¸‹è¿è¡Œã€‚

```bash
npx hardhat
```

- é€‰æ‹©`Create a basic sample project`
- å¯¹å·²æŒ‡å®šçš„`Hardhat Project root`æŒ‰å›è½¦é”®
- å¦‚æœä½ æƒ³æ·»åŠ ä¸€ä¸ª`.gitignore`ï¼Œè¯·æŒ‰å›è½¦é”®ã€‚
- æŒ‰å›è½¦é”®`Do you want to install this sample project's dependencies with npm (@nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers)?`

ç°åœ¨ä½ æœ‰ä¸€ä¸ªå‡†å¤‡å¥½çš„hardhaté¡¹ç›®äº†!

è®©æˆ‘ä»¬ä¹Ÿåœ¨åŒä¸€ç»ˆç«¯å®‰è£…OpenZeppelinåˆåŒã€‚

```
npm install @openzeppelin/contracts
```

æˆ‘ä»¬å°†åˆ›å»ºä¸¤ä¸ªæ™ºèƒ½åˆçº¦ã€‚ç¬¬ä¸€ä¸ªæ˜¯ä¸€ä¸ªè¶…çº§ç®€å•çš„ERC-20å®ç°ï¼Œç¬¬äºŒä¸ªæ˜¯æˆ‘ä»¬çš„`TokenSender`åˆçº¦ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†åœ¨åŒä¸€ä¸ª`.sol`æ–‡ä»¶ä¸­åˆ›å»ºè¿™ä¸¤ä¸ªåˆçº¦ã€‚

è®©æˆ‘ä»¬åœ¨`contracts/`ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªåä¸º`MetaTokenSender.sol`çš„Solidityæ–‡ä»¶ï¼Œä»£ç å¦‚ä¸‹:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract RandomToken is ERC20 {
    constructor() ERC20("", "") {}

    function freeMint(uint amount) public {
        _mint(msg.sender, amount);
    }
}

contract TokenSender {

    using ECDSA for bytes32;

    function transfer(address sender, uint amount, address recipient, address tokenContract, bytes memory signature) public {
        bytes32 messageHash = getHash(sender, amount, recipient, tokenContract);
        bytes32 signedMessageHash = messageHash.toEthSignedMessageHash();

        address signer = signedMessageHash.recover(signature);

        require(signer == sender, "Signature does not come from sender");

        bool sent = ERC20(tokenContract).transferFrom(sender, recipient, amount);
        require(sent, "Transfer failed");
    }

    function getHash(address sender, uint amount, address recipient, address tokenContract) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(sender, amount, recipient, tokenContract));
    }
}
```

è®©æˆ‘ä»¬æ¥çœ‹çœ‹å‘ç”Ÿäº†ä»€ä¹ˆã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸‹å¯¼å…¥ã€‚

### å¯¼å…¥

`ERC20.sol`å¯¼å…¥æ˜¯ä¸ºäº†ç»§æ‰¿OpenZeppelinçš„åŸºæœ¬ERC-20åˆçº¦å®ç°ï¼Œæˆ‘ä»¬åœ¨ä»¥å‰çš„è¯¾ç¨‹ä¸Šå·²ç»äº†è§£äº†å¾ˆå¤šã€‚

`ECDSA`æ˜¯`Elliptic Curve Digital Signature Algorithm`çš„ç¼©å†™--å®ƒæ˜¯Ethereumä½¿ç”¨çš„ç­¾åç®—æ³•ï¼Œ`ECDSA.sol`çš„OpenZeppelinåº“åŒ…å«ä¸€äº›ç”¨äºSolidityä¸­æ•°å­—ç­¾åçš„è¾…åŠ©å‡½æ•°ã€‚

### å‡½æ•°

ERC-20åˆçº¦æ˜¯ä¸è¨€è‡ªæ˜çš„ï¼Œå› ä¸ºå®ƒæ‰€åšçš„å°±æ˜¯è®©ä½ é“¸é€ ä¸€ä¸ªä»»æ„æ•°é‡çš„å…è´¹ä»£å¸ã€‚

å¯¹äº`TokenSender`ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªå‡½æ•°ã€‚è®©æˆ‘ä»¬å…ˆçœ‹çœ‹è¾…åŠ©å‡½æ•°--`getHash`--å®ƒæ¥æ”¶`sender`åœ°å€ã€ä»£å¸`amount`ã€`recipient`åœ°å€å’Œ`tokenContract`åœ°å€ï¼Œå¹¶è¿”å›å®ƒä»¬æ‰“åŒ…åœ¨ä¸€èµ·çš„`keccak256`å“ˆå¸Œå€¼ã€‚`abi.encodePacked`å°†æ‰€æœ‰æŒ‡å®šçš„å€¼è½¬æ¢ä¸ºå­—èŠ‚ï¼Œä¸­é—´ä¸ç•™ä»»ä½•å¡«å……ï¼Œå¹¶å°†å…¶ä¼ é€’ç»™keccak256ï¼Œè¿™æ˜¯ä¸€ä¸ªEthereumä½¿ç”¨çš„æ•£åˆ—å‡½æ•°ã€‚è¿™æ˜¯ä¸€ä¸ª`pure`çš„å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿå°†é€šè¿‡Javascriptåœ¨å®¢æˆ·ç«¯ä½¿ç”¨å®ƒï¼Œä»¥é¿å…åœ¨Javascriptä¸­å¤„ç†keccakæ•£åˆ—å’Œæ‰“åŒ…ç¼–ç ï¼Œè¿™å¯èƒ½ä¼šæœ‰ç‚¹çƒ¦äººã€‚

`transfer`å‡½æ•°æ˜¯ä¸€ä¸ªæœ‰è¶£çš„å‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸Šè¿°å››ä¸ªå‚æ•°å’Œä¸€ä¸ªç­¾åã€‚å®ƒä½¿ç”¨`getHash`å¸®åŠ©å™¨è®¡ç®—å“ˆå¸Œå€¼ã€‚ä¹‹åï¼Œæ ¹æ®[EIP-191](https://eips.ethereum.org/EIPS/eip-191)ï¼Œæ¶ˆæ¯å“ˆå¸Œå€¼è¢«è½¬æ¢ä¸º`Ethereum Signed Message Hash`ã€‚è°ƒç”¨è¿™ä¸ªå‡½æ•°å¯ä»¥å°†`messageHash`è½¬æ¢æˆè¿™æ ·çš„æ ¼å¼ `"\x19Ethereum Signed Message:\n" + len(message) + message)`ã€‚éµå®ˆæ ‡å‡†ä»¥å®ç°äº’æ“ä½œæ€§æ˜¯å¾ˆé‡è¦çš„ã€‚

åœ¨è¿™æ ·åšä¹‹åï¼Œä½ è°ƒç”¨`recover`æ–¹æ³•ï¼Œåœ¨è¯¥æ–¹æ³•ä¸­ä½ ä¼ é€’`signature`ï¼Œè¿™åªä¸è¿‡æ˜¯ä½ ç”¨å‘ä»¶äººçš„ç§é’¥ç­¾åçš„`Ethereum Signed Message`ï¼Œä½ å°†å…¶ä¸ä½ ç”Ÿæˆçš„`Ethereum Signed Message` - `signedMessageHash`è¿›è¡Œæ¯”è¾ƒï¼Œä»¥æ¢å¤å…¬é’¥ï¼Œè¿™åº”è¯¥æ˜¯å‘ä»¶äººçš„åœ°å€ã€‚

å¦‚æœç­¾åäººåœ°å€ä¸ä¼ å…¥çš„`sender`åœ°å€ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†ERC-20ä»£å¸ä»`sender `è½¬ç§»åˆ°`recipient`ã€‚

### Hardhat Test

è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªHardhatæµ‹è¯•æ¥æ¼”ç¤ºè¿™å°†å¦‚ä½•å·¥ä½œã€‚åœ¨`test`ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªåä¸º`metatxn-test.js`çš„æ–°æ–‡ä»¶ï¼Œä»£ç å¦‚ä¸‹

```
const { expect } = require("chai");
const { BigNumber } = require("ethers");
const { arrayify, parseEther } = require("ethers/lib/utils");
const { ethers } = require("hardhat");

describe("MetaTokenTransfer", function () {
  it("Should let user transfer tokens through a relayer", async function () {
    // Deploy the contracts
    const RandomTokenFactory = await ethers.getContractFactory("RandomToken");
    const randomTokenContract = await RandomTokenFactory.deploy();
    await randomTokenContract.deployed();

    const MetaTokenSenderFactory = await ethers.getContractFactory(
      "TokenSender"
    );
    const tokenSenderContract = await MetaTokenSenderFactory.deploy();
    await tokenSenderContract.deployed();

    // Get three addresses, treat one as the user address
    // one as the relayer address, and one as a recipient address
    const [_, userAddress, relayerAddress, recipientAddress] =
      await ethers.getSigners();

    // Mint 10,000 tokens to user address (for testing)
    const tenThousandTokensWithDecimals = parseEther("10000");
    const userTokenContractInstance = randomTokenContract.connect(userAddress);
    const mintTxn = await userTokenContractInstance.freeMint(
      tenThousandTokensWithDecimals
    );
    await mintTxn.wait();

    // Have user infinite approve the token sender contract for transferring 'RandomToken'
    const approveTxn = await userTokenContractInstance.approve(
      tokenSenderContract.address,
      BigNumber.from(
        // This is uint256's max value (2^256 - 1) in hex
        // Fun Fact: There are 64 f's in here.
        // In hexadecimal, each digit can represent 4 bits
        // f is the largest digit in hexadecimal (1111 in binary)
        // 4 + 4 = 8 i.e. two hex digits = 1 byte
        // 64 digits = 32 bytes
        // 32 bytes = 256 bits = uint256
        "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
      )
    );
    await approveTxn.wait();

    // Have user sign message to transfer 10 tokens to recipient
    const transferAmountOfTokens = parseEther("10");
    const messageHash = await tokenSenderContract.getHash(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address
    );
    const signature = await userAddress.signMessage(arrayify(messageHash));

    // Have the relayer execute the transaction on behalf of the user
    const relayerSenderContractInstance =
      tokenSenderContract.connect(relayerAddress);
    const metaTxn = await relayerSenderContractInstance.transfer(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      signature
    );
    await metaTxn.wait();

    // Check the user's balance decreased, and recipient got 10 tokens
    const userBalance = await randomTokenContract.balanceOf(
      userAddress.address
    );
    const recipientBalance = await randomTokenContract.balanceOf(
      recipientAddress.address
    );

    expect(userBalance.lt(tenThousandTokensWithDecimals)).to.be.true;
    expect(recipientBalance.gt(BigNumber.from(0))).to.be.true;
  });
});
```

ä»£ç åœ¨è¯„è®ºé‡Œæœ‰è§£é‡Šï¼Œä½†è®©æˆ‘ä»¬è¯•ç€è¿è¡Œæµ‹è¯•ã€‚ä½ å¯ä»¥åœ¨ç»ˆç«¯è¾“å…¥`npx hardhat test`æ¥è¿è¡Œæµ‹è¯•ï¼Œå¦‚æœä½ åšçš„ä¸€åˆ‡æ­£ç¡®ï¼Œåº”è¯¥ä¼šé€šè¿‡

è¿™æ„å‘³ç€ï¼Œåœ¨åˆæ­¥æ‰¹å‡†åï¼Œå‘é€æ–¹èƒ½å¤Ÿå‘æ¥æ”¶æ–¹è½¬ç§»10ä¸ªä»£å¸ï¼Œè€Œä¸éœ€è¦è‡ªå·±æ”¯ä»˜æ±½æ²¹ã€‚ä½ å¯ä»¥è¿›ä¸€æ­¥è½»æ¾åœ°æ‰©å±•è¿™ä¸ªæµ‹è¯•ï¼Œçœ‹çœ‹è¿™ç”šè‡³ä¼šå¯¹å¤šæ¬¡è½¬è´¦èµ·ä½œç”¨ï¼Œåªè¦ä½ ä¸è¶…è¿‡ç”¨æˆ·çš„10000ä¸ªä»£å¸çš„ä½™é¢ã€‚

## å®‰å…¨æ¼æ´

ä¸è¿‡ä½ èƒ½çŒœåˆ°æˆ‘ä»¬åˆšæ‰å†™çš„ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜å—ï¼ŸğŸ¤”

ç”±äºç­¾ååŒ…å«å¿…è¦çš„ä¿¡æ¯ï¼Œä¸­ç»§è€…å¯ä»¥ä¸æ–­åœ°å°†ç­¾åå‘é€ç»™åˆåŒï¼Œä»è€Œä¸æ–­åœ°å°†ä»£å¸ä»`sender's`çš„è´¦æˆ·è½¬ç§»åˆ°`recipient's`çš„è´¦æˆ·ã€‚

è™½ç„¶åœ¨è¿™ä¸ªå…·ä½“çš„ä¾‹å­ä¸­ï¼Œè¿™ä¼¼ä¹ä¸æ˜¯ä»€ä¹ˆå¤§é—®é¢˜ï¼Œä½†å¦‚æœè¿™ä¸ªåˆåŒæ˜¯è´Ÿè´£å¤„ç†ä¸»ç½‘çš„èµ„é‡‘é—®é¢˜å‘¢ï¼Ÿå¦‚æœåŒæ ·çš„ç­¾åå¯ä»¥è¢«åå¤ä½¿ç”¨ï¼Œç”¨æˆ·å°†å¤±å»ä»–ä»¬æ‰€æœ‰çš„ä»£å¸

ç›¸åï¼Œåªæœ‰å½“ç”¨æˆ·æ˜ç¡®æä¾›ç¬¬äºŒä¸ªç­¾åæ—¶ï¼Œäº¤æ˜“æ‰ä¼šè¢«æ‰§è¡Œï¼ˆå½“ç„¶æ˜¯åœ¨æ™ºèƒ½åˆçº¦çš„è§„åˆ™å†…ï¼‰ã€‚

è¿™ç§æ”»å‡»è¢«ç§°ä¸ºç­¾åé‡æ”¾--å› ä¸ºï¼Œä½ çŒœå¯¹äº†ï¼Œä½ é‡æ”¾äº†ä¸€ä¸ªç­¾åã€‚

## è§£å†³ç­¾åå›æ”¾çš„é—®é¢˜

å¯¹äºæ›´ç®€å•çš„åˆåŒï¼Œä½ å¯ä»¥é€šè¿‡åœ¨åˆåŒä¸­è®¾ç½®ä¸€äº›ï¼ˆåµŒå¥—ï¼‰çš„æ˜ å°„æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä½†æ˜¯æ¯æ¬¡è½¬è´¦æœ‰4ä¸ªå˜é‡éœ€è¦è·Ÿè¸ª--`sender`ã€`amount`ã€`recipient`å’Œ`tokenContract`ã€‚åœ¨Solidityä¸­ï¼Œåˆ›å»ºä¸€ä¸ªè¿™ä¹ˆæ·±çš„åµŒå¥—æ˜ å°„å¯èƒ½æ˜¯ç›¸å½“æ˜‚è´µçš„ã€‚

è€Œä¸”ï¼Œæ¯ä¸€ç§æ™ºèƒ½åˆçº¦çš„ "ç§ç±» "éƒ½æ˜¯ä¸åŒçš„--å› ä¸ºä½ å¹¶ä¸æ€»æ˜¯åœ¨å¤„ç†ç›¸åŒçš„ç”¨ä¾‹ã€‚ä¸€ä¸ªæ›´é€šç”¨çš„è§£å†³æ–¹æ¡ˆæ˜¯åˆ›å»ºä¸€ä¸ªä»å‚æ•°å“ˆå¸Œåˆ°å¸ƒå°”å€¼çš„å•ä¸€æ˜ å°„ï¼Œå…¶ä¸­`true`è¡¨ç¤ºè¿™ä¸ªå…ƒäº¤æ˜“å·²ç»è¢«æ‰§è¡Œï¼Œ`false`è¡¨ç¤ºæ²¡æœ‰ã€‚

ç±»ä¼¼äº`mapping(bytes32 => bool)`ã€‚

ä¸è¿‡è¿™ä¹Ÿæœ‰ä¸€ä¸ªé—®é¢˜ã€‚åœ¨ç›®å‰çš„å‚æ•°è®¾ç½®ä¸‹ï¼Œå¦‚æœAliceå‘Bobå‘é€äº†10ä¸ªä»¤ç‰Œï¼Œå®ƒå°†åœ¨ç¬¬ä¸€æ¬¡é€šè¿‡ï¼Œå¹¶ä¸”æ˜ å°„å°†è¢«æ›´æ–°ä»¥åæ˜ è¿™ä¸€ç‚¹ã€‚ç„¶è€Œï¼Œå¦‚æœAliceçœŸçš„æƒ³åœ¨ç¬¬äºŒæ¬¡å‘Bobå†å‘é€10ä¸ªä»£å¸å‘¢ï¼Ÿ

ç”±äºæ•°å­—ç­¾åæ˜¯ç¡®å®šæ€§çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºåŒä¸€ç»„å¯†é’¥æ¥è¯´ï¼Œç›¸åŒçš„è¾“å…¥å°†å¾—åˆ°ç›¸åŒçš„è¾“å‡ºï¼Œè¿™æ„å‘³ç€Aliceå°†æ°¸è¿œæ— æ³•å†å‘Bobå‘é€10ä¸ªä»¤ç‰Œäº†

ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å¼•å…¥äº†ç¬¬äº”ä¸ªå‚æ•°ï¼Œå³`nonce`ã€‚

`nonce`åªæ˜¯ä¸€ä¸ªéšæœºæ•°å€¼ï¼Œå¯ä»¥ç”±ç”¨æˆ·é€‰æ‹©ï¼Œä¹Ÿå¯ä»¥ç”±åˆåŒé€‰æ‹©ï¼Œè¿˜å¯ä»¥éšæœºç”Ÿæˆï¼Œè¿™éƒ½ä¸é‡è¦--åªè¦ç”¨æˆ·çš„ç­¾ååŒ…æ‹¬è¿™ä¸ªnonceã€‚ç”±äºå®Œå…¨ç›¸åŒçš„äº¤æ˜“ä½†ä½¿ç”¨ä¸åŒçš„nonceä¼šäº§ç”Ÿä¸åŒçš„ç­¾åï¼Œæ‰€ä»¥ä¸Šè¿°é—®é¢˜å°±è§£å†³äº†!

è®©æˆ‘ä»¬æ¥å®æ–½è¿™ä¸ªğŸš€

### æ™ºèƒ½åˆçº¦çš„å˜åŒ–

æˆ‘ä»¬éœ€è¦åœ¨ä¸‰ä¸ªåœ°æ–¹æ›´æ–°æ™ºèƒ½åˆçº¦çš„ä»£ç ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å°†æ·»åŠ ä¸€ä¸ª`mapping(bytes32 => bool)`æ¥è·Ÿè¸ªå“ªäº›ç­¾åå·²ç»è¢«æ‰§è¡Œã€‚

ç¬¬äºŒï¼Œæˆ‘ä»¬å°†æ›´æ–°æˆ‘ä»¬çš„è¾…åŠ©å‡½æ•°`getHash`ï¼Œä»¥æ¥å—ä¸€ä¸ª`nonce`å‚æ•°ï¼Œå¹¶å°†å…¶çº³å…¥å“ˆå¸Œå€¼ã€‚

ç¬¬ä¸‰ï¼Œæˆ‘ä»¬å°†æ›´æ–°æˆ‘ä»¬çš„`transfer`å‡½æ•°ï¼Œä»¥ä¾¿åœ¨éªŒè¯ç­¾åæ—¶ä¹Ÿæ¥æ”¶`nonce`å¹¶å°†å…¶ä¼ é€’ç»™`getHash`ã€‚å®ƒä¹Ÿä¼šåœ¨ç­¾åéªŒè¯åæ›´æ–°æ˜ å°„ã€‚

ä¸‹é¢æ˜¯æ›´æ–°åçš„ä»£ç ã€‚

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract RandomToken is ERC20 {
    constructor() ERC20("", "") {}

    function freeMint(uint amount) public {
        _mint(msg.sender, amount);
    }
}

contract TokenSender {

    using ECDSA for bytes32;

    // New mapping
    mapping(bytes32 => bool) executed;

    // Add the nonce parameter here
    function transfer(address sender, uint amount, address recipient, address tokenContract, uint nonce, bytes memory signature) public {
        // Pass ahead the nonce
        bytes32 messageHash = getHash(sender, amount, recipient, tokenContract, nonce);
        bytes32 signedMessageHash = messageHash.toEthSignedMessageHash();

        // Require that this signature hasn't already been executed
        require(!executed[signedMessageHash], "Already executed!");

        address signer = signedMessageHash.recover(signature);

        require(signer == sender, "Signature does not come from sender");

        // Mark this signature as having been executed now
        executed[signedMessageHash] = true;
        bool sent = ERC20(tokenContract).transferFrom(sender, recipient, amount);
        require(sent, "Transfer failed");
    }

    // Add the nonce parameter here
    function getHash(address sender, uint amount, address recipient, address tokenContract, uint nonce) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(sender, amount, recipient, tokenContract, nonce));
    }
}
```

è®©æˆ‘ä»¬ä¹Ÿæ¥æ›´æ–°æˆ‘ä»¬çš„æµ‹è¯•ä»¥åæ˜ è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å°†æœ‰ä¸¤ä¸ªæµ‹è¯•--ä¸€ä¸ªæ˜¯è¯æ˜ç­¾åä¸èƒ½å†è¢«é‡æ”¾ï¼Œå¦ä¸€ä¸ªæ˜¯è¯æ˜ä¸¤ä¸ªä¸åŒçš„ç­¾åä¸ä¸åŒçš„noncesä»ç„¶å¯ä»¥å·¥ä½œï¼Œå³ä½¿å…¶ä»–ä¸œè¥¿éƒ½æ˜¯ä¸€æ ·çš„ã€‚

ä»¥ä¸‹æ˜¯æœ€æ–°çš„æµ‹è¯•

```
const { expect } = require("chai");
const { BigNumber } = require("ethers");
const { arrayify, parseEther } = require("ethers/lib/utils");
const { ethers } = require("hardhat");

describe("MetaTokenTransfer", function () {
  it("Should let user transfer tokens through a relayer with different nonces", async function () {
    // Deploy the contracts
    const RandomTokenFactory = await ethers.getContractFactory("RandomToken");
    const randomTokenContract = await RandomTokenFactory.deploy();
    await randomTokenContract.deployed();

    const MetaTokenSenderFactory = await ethers.getContractFactory(
      "TokenSender"
    );
    const tokenSenderContract = await MetaTokenSenderFactory.deploy();
    await tokenSenderContract.deployed();

    // Get three addresses, treat one as the user address
    // one as the relayer address, and one as a recipient address
    const [_, userAddress, relayerAddress, recipientAddress] =
      await ethers.getSigners();

    // Mint 10,000 tokens to user address (for testing)
    const tenThousandTokensWithDecimals = parseEther("10000");
    const userTokenContractInstance = randomTokenContract.connect(userAddress);
    const mintTxn = await userTokenContractInstance.freeMint(
      tenThousandTokensWithDecimals
    );
    await mintTxn.wait();

    // Have user infinite approve the token sender contract for transferring 'RandomToken'
    const approveTxn = await userTokenContractInstance.approve(
      tokenSenderContract.address,
      BigNumber.from(
        // This is uint256's max value (2^256 - 1) in hex
        "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
      )
    );
    await approveTxn.wait();

    // Have user sign message to transfer 10 tokens to recipient
    let nonce = 1;

    const transferAmountOfTokens = parseEther("10");
    const messageHash = await tokenSenderContract.getHash(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      nonce
    );
    const signature = await userAddress.signMessage(arrayify(messageHash));

    // Have the relayer execute the transaction on behalf of the user
    const relayerSenderContractInstance =
      tokenSenderContract.connect(relayerAddress);
    const metaTxn = await relayerSenderContractInstance.transfer(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      nonce,
      signature
    );
    await metaTxn.wait();

    // Check the user's balance decreased, and recipient got 10 tokens
    let userBalance = await randomTokenContract.balanceOf(userAddress.address);
    let recipientBalance = await randomTokenContract.balanceOf(
      recipientAddress.address
    );

    expect(userBalance.eq(parseEther("9990"))).to.be.true;
    expect(recipientBalance.eq(parseEther("10"))).to.be.true;

    // Increment the nonce
    nonce++;

    // Have user sign a second message, with a different nonce, to transfer 10 more tokens
    const messageHash2 = await tokenSenderContract.getHash(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      nonce
    );
    const signature2 = await userAddress.signMessage(arrayify(messageHash2));
    // Have the relayer execute the transaction on behalf of the user
    const metaTxn2 = await relayerSenderContractInstance.transfer(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      nonce,
      signature2
    );
    await metaTxn2.wait();

    // Check the user's balance decreased, and recipient got 10 tokens
    userBalance = await randomTokenContract.balanceOf(userAddress.address);
    recipientBalance = await randomTokenContract.balanceOf(
      recipientAddress.address
    );

    expect(userBalance.eq(parseEther("9980"))).to.be.true;
    expect(recipientBalance.eq(parseEther("20"))).to.be.true;
  });

  it("Should not let signature replay happen", async function () {
    // Deploy the contracts
    const RandomTokenFactory = await ethers.getContractFactory("RandomToken");
    const randomTokenContract = await RandomTokenFactory.deploy();
    await randomTokenContract.deployed();

    const MetaTokenSenderFactory = await ethers.getContractFactory(
      "TokenSender"
    );
    const tokenSenderContract = await MetaTokenSenderFactory.deploy();
    await tokenSenderContract.deployed();

    // Get three addresses, treat one as the user address
    // one as the relayer address, and one as a recipient address
    const [_, userAddress, relayerAddress, recipientAddress] =
      await ethers.getSigners();

    // Mint 10,000 tokens to user address (for testing)
    const tenThousandTokensWithDecimals = parseEther("10000");
    const userTokenContractInstance = randomTokenContract.connect(userAddress);
    const mintTxn = await userTokenContractInstance.freeMint(
      tenThousandTokensWithDecimals
    );
    await mintTxn.wait();

    // Have user infinite approve the token sender contract for transferring 'RandomToken'
    const approveTxn = await userTokenContractInstance.approve(
      tokenSenderContract.address,
      BigNumber.from(
        // This is uint256's max value (2^256 - 1) in hex
        "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
      )
    );
    await approveTxn.wait();

    // Have user sign message to transfer 10 tokens to recipient
    let nonce = 1;

    const transferAmountOfTokens = parseEther("10");
    const messageHash = await tokenSenderContract.getHash(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      nonce
    );
    const signature = await userAddress.signMessage(arrayify(messageHash));

    // Have the relayer execute the transaction on behalf of the user
    const relayerSenderContractInstance =
      tokenSenderContract.connect(relayerAddress);
    const metaTxn = await relayerSenderContractInstance.transfer(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      nonce,
      signature
    );
    await metaTxn.wait();

    // Have the relayer attempt to execute the same transaction again with the same signature
    // This time, we expect the transaction to be reverted because the signature has already been used.
    expect(relayerSenderContractInstance.transfer(
      userAddress.address,
      transferAmountOfTokens,
      recipientAddress.address,
      randomTokenContract.address,
      nonce,
      signature
    )).to.be.revertedWith('Already executed!');
  });
});
```

è¿™é‡Œçš„ç¬¬ä¸€ä¸ªæµ‹è¯•æ˜¯è®©ç”¨æˆ·ç”¨ä¸¤ä¸ªä¸åŒçš„noncesç­¾ç½²ä¸¤ä¸ªä¸åŒçš„ç­¾åï¼Œå¹¶ä¸”ä¸­ç»§å™¨éƒ½æ‰§è¡Œäº†è¿™ä¸¤ä¸ªç­¾åã€‚ç„¶è€Œï¼Œåœ¨ç¬¬äºŒä¸ªæµ‹è¯•ä¸­ï¼Œä¸­ç»§å™¨è¯•å›¾æ‰§è¡ŒåŒä¸€ä¸ªç­¾åä¸¤æ¬¡ã€‚åœ¨ä¸­ç»§å™¨ç¬¬äºŒæ¬¡è¯•å›¾ä½¿ç”¨ç›¸åŒçš„ç­¾åæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›äº¤æ˜“èƒ½è¢«è¿˜åŸã€‚

å¦‚æœä½ åœ¨è¿™é‡Œè¿è¡Œ`npx hardhat test`ï¼Œå¹¶ä¸”æ‰€æœ‰æµ‹è¯•éƒ½æˆåŠŸäº†ï¼Œè¿™æ„å‘³ç€å¸¦æœ‰é‡æ”¾æ”»å‡»çš„ç¬¬äºŒä¸ªäº¤æ˜“è¢«è¿˜åŸäº†ã€‚

è¿™è¡¨æ˜ç­¾åé‡æ”¾ä¸å†å‘ç”Ÿï¼Œè¯¥æ¼æ´å·²è¢«ä¿æŠ¤èµ·æ¥!ğŸ¥³ğŸ¥³

## æ€»ç»“

è¿™æ˜¯ä¸ªæ¯”æˆ‘é¢„æœŸçš„è¦é•¿çš„æ•™ç¨‹ï¼Œä½†æˆ‘å¸Œæœ›ä½ èƒ½å­¦åˆ°ä¸€äº›å¾ˆé…·çš„ä¸œè¥¿!å…ƒäº¤æ˜“æ˜¯ä¸€ä¸ªä¼Ÿå¤§çš„å®ç”¨å·¥å…·ï¼Œä½†è¦ç¡®ä¿ä½ æ­£ç¡®åœ°ä½¿ç”¨å®ƒä»¬ã€‚

![](https://hicoldcat.oss-cn-hangzhou.aliyuncs.com/img/my.png)
